{"version":3,"sources":["meteor://ðŸ’»app/packages/meson_electron/server/createBinaries.js","meteor://ðŸ’»app/packages/meson_electron/server/downloadUrls.js","meteor://ðŸ’»app/packages/meson_electron/server/launchApp.js","meteor://ðŸ’»app/packages/meson_electron/server/serve.js","meteor://ðŸ’»app/packages/meson_electron/server/serveDownloadUrl.js","meteor://ðŸ’»app/packages/meson_electron/server/serveUpdateFeed.js","meteor://ðŸ’»app/packages/meson_electron/server/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/meson_electron.js","sourcesContent":["var electronPackager = Meteor.wrapAsync(Npm.require(\"electron-packager\"));\nvar fs = Npm.require('fs');\nvar mkdirp = Meteor.wrapAsync(Npm.require('mkdirp'));\nvar path = Npm.require('path');\nvar proc = Npm.require('child_process');\nvar dirsum = Meteor.wrapAsync(Npm.require('lucy-dirsum'));\nvar readFile = Meteor.wrapAsync(fs.readFile);\nvar writeFile = Meteor.wrapAsync(fs.writeFile);\nvar stat = Meteor.wrapAsync(fs.stat);\nvar util = Npm.require('util');\nvar rimraf = Meteor.wrapAsync(Npm.require('rimraf'));\nvar ncp = Meteor.wrapAsync(Npm.require('ncp'));\n\nvar exec = Meteor.wrapAsync(function(command, options, callback){\n  proc.exec(command, options, function(err, stdout, stderr){\n    callback(err, {stdout: stdout, stderr: stderr});\n  });\n});\n\nvar exists = function(path) {\n  try {\n    stat(path);\n    return true;\n  } catch(e) {\n    return false;\n  }\n};\n\nvar projectRoot = function(){\n  if (process.platform === \"win32\"){\n    return process.env.METEOR_SHELL_DIR.split(\".meteor\")[0];\n  } else {\n    return process.env.PWD;\n  }\n};\n\nvar ELECTRON_VERSION = '0.36.2';\n\nvar electronSettings = Meteor.settings.electron || {};\n\nvar IS_MAC = (process.platform === 'darwin');\n\n/* Entry Point */\ncreateBinaries = function() {\n  var results = {};\n  var builds;\n  if (electronSettings.builds){\n    builds = electronSettings.builds;\n  } else {\n    //just build for the current platform/architecture\n    if (process.platform === \"darwin\"){\n      builds = [{platform: process.platform, arch: process.arch}];\n    } else if (process.platform === \"win32\"){\n      //arch detection doesn't always work on windows, and ia32 works everywhere\n      builds = [{platform: process.platform, arch: \"ia32\"}];\n    } else {\n      console.error('You must specify one or more builds in Meteor.settings.electron.');\n      return results;\n    }\n  }\n\n  if (_.isEmpty(builds)) {\n    console.error('No builds available for this platform.');\n    return results;\n  }\n\n  builds.forEach(function(buildInfo){\n    var buildRequired = false;\n\n    var buildDirs = createBuildDirectories(buildInfo);\n\n    /* Write out Electron application files */\n    var appVersion = electronSettings.version;\n    var appName = electronSettings.name || \"electron\";\n    var appDescription = electronSettings.description;\n\n    var resolvedAppSrcDir;\n    if (electronSettings.appSrcDir) {\n      resolvedAppSrcDir = path.join(projectRoot(), electronSettings.appSrcDir);\n    } else {\n      // See http://stackoverflow.com/a/29745318/495611 for how the package asset directory is derived.\n      // We can't read this from the project directory like the user-specified app directory since\n      // we may be loaded from Atmosphere rather than locally.\n      resolvedAppSrcDir = path.join(process.cwd(), 'assets', 'packages', 'meson_electron', 'app');\n    }\n\n    // Check if the package.json has changed before copying over the app files, to account for\n    // changes made in the app source dir.\n    var packagePath = packageJSONPath(resolvedAppSrcDir);\n    var packageJSON = Npm.require(packagePath);\n\n    // Fill in missing package.json fields (note: before the comparison).\n    // This isn't just a convenience--`Squirrel.Windows` requires the description and version.\n    packageJSON = _.defaults(packageJSON, {\n      name: appName && appName.toLowerCase().replace(/\\s/g, '-'),\n      productName: appName,\n      description: appDescription,\n      version: appVersion\n    });\n    // Check if the package has changed before we possibly copy over the app source since that will\n    // of course sync `package.json`.\n    var packageHasChanged = packageJSONHasChanged(packageJSON, buildDirs.app);\n\n    var didOverwriteNodeModules = false;\n\n    if (appHasChanged(resolvedAppSrcDir, buildDirs.working)) {\n      buildRequired = true;\n\n      // Copy the app directory over while also pruning old files.\n      if (IS_MAC) {\n        // Ensure that the app source directory ends in a slash so we copy its contents.\n        // Except node_modules from pruning since we prune that below.\n        // TODO(wearhere): `rsync` also uses checksums to only copy what's necessary so theoretically we\n        // could always `rsync` rather than checking if the directory's changed first.\n         exec(util.format('rsync -a --delete --force --filter=\"P node_modules\" \"%s\" \"%s\"',\n          path.join(resolvedAppSrcDir, '/'), buildDirs.app));\n      } else {\n        // TODO(wearhere): More efficient sync on Windows (where `rsync` isn't available.)\n        rimraf(buildDirs.app);\n        mkdirp(buildDirs.app);\n        ncp(resolvedAppSrcDir, buildDirs.app);\n        didOverwriteNodeModules = true;\n      }\n    }\n\n    /* Write out the application package.json */\n    // Do this after writing out the application files, since that will overwrite `package.json`.\n    // This logic is a little bit inefficient: it's not the case that _every_ change to package.json\n    // means that we have to reinstall the node modules; and if we overwrote the node modules, we\n    // don't necessarily have to rewrite `package.json`. But doing it altogether is simplest.\n    if (packageHasChanged || didOverwriteNodeModules) {\n      buildRequired = true;\n\n      // For some reason when this file isn't manually removed it fails to be overwritten with an\n      // EACCES error.\n      rimraf(packageJSONPath(buildDirs.app));\n      writeFile(packageJSONPath(buildDirs.app), JSON.stringify(packageJSON));\n\n      exec(\"npm install && npm prune\", {cwd: buildDirs.app});\n    }\n\n    /* Write out Electron Settings */\n    var settings = _.defaults({}, electronSettings, {\n      rootUrl: process.env.ROOT_URL\n    });\n\n    var signingIdentity = electronSettings.sign;\n    var signingIdentityRequiredAndMissing = false;\n    if (canServeUpdates(buildInfo.platform)) {\n      // Enable the auto-updater if possible.\n      if ((buildInfo.platform === 'darwin') && !signingIdentity) {\n        // If the app isn't signed and we try to use the auto-updater, it will\n        // throw an exception. Log an error if the settings have changed, below.\n        signingIdentityRequiredAndMissing = true;\n      } else {\n        settings.updateFeedUrl = settings.rootUrl + UPDATE_FEED_PATH;\n      }\n    }\n\n    if (settingsHaveChanged(settings, buildDirs.app)) {\n      if (signingIdentityRequiredAndMissing) {\n        console.error('Developer ID signing identity is missing: remote updates will not work.');\n      }\n      buildRequired = true;\n      writeFile(settingsPath(buildDirs.app), JSON.stringify(settings));\n    }\n\n    var packagerSettings = getPackagerSettings(buildInfo, buildDirs);\n    if (packagerSettings.icon && iconHasChanged(packagerSettings.icon, buildDirs.working)) {\n      buildRequired = true;\n    }\n\n    // TODO(wearhere): If/when the signing identity expires, does its name change? If not, we'll need\n    // to force the app to be rebuilt somehow.\n\n    if (packagerSettingsHaveChanged(packagerSettings, buildDirs.working)) {\n      buildRequired = true;\n    }\n\n    var app = appPath(appName, buildInfo.platform, buildInfo.arch, buildDirs.build);\n    if (!exists(app)) {\n      buildRequired = true;\n    }\n\n    /* Create Build */\n    if (buildRequired) {\n      var build = electronPackager(packagerSettings)[0];\n      console.log(\"Build created for \", buildInfo.platform, buildInfo.arch, \"at\", build);\n    }\n\n    /* Package the build for download if specified. */\n    // TODO(rissem): make this platform independent\n\n    if (electronSettings.autoPackage && (buildInfo.platform === 'darwin')) {\n      // The auto-updater framework only supports installing ZIP releases:\n      // https://github.com/Squirrel/Squirrel.Mac#update-json-format\n      var downloadName = (appName || \"app\") + \".zip\";\n      var compressedDownload = path.join(buildDirs.final, downloadName);\n\n      if (buildRequired || !exists(compressedDownload)) {\n        // Use `ditto` to ZIP the app because I couldn't find a good npm module to do it and also that's\n        // what a couple of other related projects do:\n        // - https://github.com/Squirrel/Squirrel.Mac/blob/8caa2fa2007b29a253f7f5be8fc9f36ace6aa30e/Squirrel/SQRLZipArchiver.h#L24\n        // - https://github.com/jenslind/electron-release/blob/4a2a701c18664ec668c3570c3907c0fee72f5e2a/index.js#L109\n        exec('ditto -ck --sequesterRsrc --keepParent \"' + app + '\" \"' + compressedDownload + '\"');\n        console.log(\"Downloadable created at\", compressedDownload);\n      }\n    }\n\n    results[buildInfo.platform + \"-\" + buildInfo.arch] = {\n      app: app,\n      buildRequired: buildRequired\n    };\n  });\n\n  return results;\n};\n\nfunction createBuildDirectories(build){\n  // Use a predictable directory so that other scripts can locate the builds, also so that the builds\n  // may be cached:\n\n  var workingDir = path.join(projectRoot(), '.meteor-electron', build.platform + \"-\" + build.arch);\n  mkdirp(workingDir);\n\n  //TODO consider seeding the binaryDir from package assets so package\n  //could work without an internet connection\n\n  // *binaryDir* holds the vanilla electron apps\n  var binaryDir = path.join(workingDir, \"releases\");\n  mkdirp(binaryDir);\n\n  // *appDir* holds the electron application that points to a meteor app\n  var appDir = path.join(workingDir, \"apps\");\n  mkdirp(appDir);\n\n  // *buildDir* contains the uncompressed apps\n  var buildDir = path.join(workingDir, \"builds\");\n  mkdirp(buildDir);\n\n  // *finalDir* contains zipped apps ready to be downloaded\n  var finalDir = path.join(workingDir, \"final\");\n  mkdirp(finalDir);\n\n  return {\n    working: workingDir,\n    binary: binaryDir,\n    app: appDir,\n    build: buildDir,\n    final: finalDir\n  };\n}\n\nfunction getPackagerSettings(buildInfo, dirs){\n  var packagerSettings = {\n    dir: dirs.app,\n    name: electronSettings.name || \"Electron\",\n    platform: buildInfo.platform,\n    arch: buildInfo.arch,\n    version: ELECTRON_VERSION,\n    out: dirs.build,\n    cache: dirs.binary,\n    overwrite: true,\n    // The EXE's `ProductName` is the preferred title of application shortcuts created by `Squirrel.Windows`.\n    // If we don't set it, it will default to \"Electron\".\n    'version-string': {\n      ProductName: electronSettings.name || 'Electron'\n    }\n  };\n\n  if (electronSettings.version) {\n    packagerSettings['app-version'] = electronSettings.version;\n  }\n  if (electronSettings.icon) {\n    var icon = electronSettings.icon[buildInfo.platform];\n    if (icon) {\n      var iconPath = path.join(projectRoot(), icon);\n      packagerSettings.icon = iconPath;\n    }\n  }\n  if (electronSettings.sign) {\n    packagerSettings.sign = electronSettings.sign;\n  }\n  if (electronSettings.protocols) {\n    packagerSettings.protocols = electronSettings.protocols;\n  }\n  return packagerSettings;\n}\n\nfunction settingsPath(appDir) {\n  return path.join(appDir, 'electronSettings.json');\n}\n\nfunction settingsHaveChanged(settings, appDir) {\n  var electronSettingsPath = settingsPath(appDir);\n  var existingElectronSettings;\n  try {\n    existingElectronSettings = Npm.require(electronSettingsPath);\n  } catch(e) {\n    // No existing settings.\n  }\n  return !existingElectronSettings || !_.isEqual(settings, existingElectronSettings);\n}\n\nfunction appHasChanged(appSrcDir, workingDir) {\n  var appChecksumPath = path.join(workingDir, 'appChecksum.txt');\n  var existingAppChecksum;\n  try {\n    existingAppChecksum = readFile(appChecksumPath, 'utf8');\n  } catch(e) {\n    // No existing checksum.\n  }\n\n  var appChecksum = dirsum(appSrcDir);\n  if (appChecksum !== existingAppChecksum) {\n    writeFile(appChecksumPath, appChecksum);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction packageJSONPath(appDir) {\n  return path.join(appDir, 'package.json');\n}\n\nfunction packageJSONHasChanged(packageJSON, appDir) {\n  var packagePath = packageJSONPath(appDir);\n  var existingPackageJSON;\n  try {\n    existingPackageJSON = Npm.require(packagePath);\n  } catch(e) {\n    // No existing package.\n  }\n\n  return !existingPackageJSON || !_.isEqual(packageJSON, existingPackageJSON);\n}\n\nfunction packagerSettingsHaveChanged(settings, workingDir) {\n  var settingsPath = path.join(workingDir, 'lastUsedPackagerSettings.json');\n  var existingPackagerSettings;\n  try {\n    existingPackagerSettings = Npm.require(settingsPath);\n  } catch(e) {\n    // No existing settings.\n  }\n\n  if (!existingPackagerSettings || !_.isEqual(settings, existingPackagerSettings)) {\n    writeFile(settingsPath, JSON.stringify(settings));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction iconHasChanged(iconPath, workingDir) {\n  var iconChecksumPath = path.join(workingDir, 'iconChecksum.txt');\n  var existingIconChecksum;\n  try {\n    existingIconChecksum = readFile(iconChecksumPath, 'utf8');\n  } catch(e) {\n    // No existing checksum.\n  }\n\n  // `dirsum` works for files too.\n  var iconChecksum = dirsum(iconPath);\n  if (iconChecksum !== existingIconChecksum) {\n    writeFile(iconChecksumPath, iconChecksum);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction appPath(appName, platform, arch, buildDir) {\n  var appExtension = (platform === 'darwin') ? '.app' : '.exe';\n  return path.join(buildDir, [appName, platform, arch].join('-'), appName + appExtension);\n}\n","var urlJoin = Npm.require('url-join');\n\n// Global for tests.\nparseMacDownloadUrl = function(electronSettings) {\n  if (!electronSettings || !electronSettings.downloadUrls || !electronSettings.downloadUrls.darwin) return;\n\n  return electronSettings.downloadUrls.darwin.replace('{{version}}', electronSettings.version);\n};\n\n// Global for tests.\nparseWindowsDownloadUrls = function(electronSettings) {\n  if (!electronSettings || !electronSettings.downloadUrls || !electronSettings.downloadUrls.win32) return;\n\n  // The default value here is what `createBinaries` writes into the app's package.json, which is\n  // what is read by `grunt-electron-installer` to name the installer.\n  var appName = electronSettings.name || 'electron';\n\n  var releasesUrl, installerUrl;\n  var installerUrlIsVersioned = false;\n\n  if (_.isString(electronSettings.downloadUrls.win32)) {\n    if (electronSettings.downloadUrls.win32.indexOf('{{version}}') > -1) {\n      console.error('Only the Windows installer URL may be versioned. Specify `downloadUrls.win32.installer`.');\n      return;\n    }\n    releasesUrl = electronSettings.downloadUrls.win32;\n    // 'AppSetup.exe' refers to the output of `grunt-electron-installer`.\n    installerUrl = urlJoin(electronSettings.downloadUrls.win32, appName + 'Setup.exe');\n  } else {\n    releasesUrl = electronSettings.downloadUrls.win32.releases;\n    if (releasesUrl.indexOf('{{version}}') > -1) {\n      console.error('Only the Windows installer URL may be versioned.');\n      return;\n    }\n    installerUrl = electronSettings.downloadUrls.win32.installer;\n    if (installerUrl.indexOf('{{version}}') > -1) {\n      installerUrl = installerUrl.replace('{{version}}', electronSettings.version);\n      installerUrlIsVersioned = true;\n    }\n  }\n\n  // Cachebust the installer URL if it's not versioned.\n  // (The releases URL will also be cachebusted, but by `serveUpdateFeed` since we've got to append\n  // the particular paths requested by the client).\n  if (!installerUrlIsVersioned) {\n    installerUrl = cachebustedUrl(installerUrl);\n  }\n\n  return {\n    releases: releasesUrl,\n    installer: installerUrl\n  };\n};\n\nfunction cachebustedUrl(url) {\n  var querySeparator = (url.indexOf('?') > -1) ? '&' : '?';\n  return url + querySeparator + 'cb=' + Date.now();\n}\n\nDOWNLOAD_URLS = {\n  darwin: parseMacDownloadUrl(Meteor.settings.electron),\n  win32: parseWindowsDownloadUrls(Meteor.settings.electron)\n};\n","var isRunning = Meteor.wrapAsync(Npm.require(\"is-running\"));\nvar path = Npm.require('path');\nvar proc = Npm.require('child_process');\n\nvar ElectronProcesses = new Mongo.Collection(\"processes\");\n\nvar ProcessManager = {\n  add: function(pid){\n    ElectronProcesses.insert({ pid: pid });\n  },\n\n  running: function(){\n    var runningProcess;\n    ElectronProcesses.find().forEach(function(proc){\n      if (isRunning(proc.pid)){\n        runningProcess = proc.pid;\n      } else {\n        ElectronProcesses.remove({ _id: proc._id });\n      }\n    });\n    return runningProcess;\n  },\n\n  stop: function(pid) {\n    process.kill(pid);\n    ElectronProcesses.remove({ pid: pid });\n  }\n};\n\nlaunchApp = function(app, appIsNew) {\n  // Safeguard.\n  if (process.env.NODE_ENV !== 'development') return;\n\n  var runningProcess = ProcessManager.running();\n  if (runningProcess) {\n    if (!appIsNew) {\n      return;\n    } else {\n      ProcessManager.stop(runningProcess);\n    }\n  }\n\n  var electronExecutable, child;\n  if (process.platform === 'win32') {\n    electronExecutable = app;\n    child = proc.spawn(electronExecutable);\n  } else {\n    electronExecutable = path.join(app, \"Contents\", \"MacOS\", \"Electron\");\n    var appDir = path.join(app, \"Contents\", \"Resources\", \"app\");\n\n    //TODO figure out how to handle case where electron executable or\n    //app dir don't exist\n\n    child = proc.spawn(electronExecutable, [appDir]);\n  }\n\n  child.stdout.on(\"data\", function(data){\n    console.log(\"ATOM:\", data.toString());\n  });\n\n  child.stderr.on(\"data\", function(data){\n    console.log(\"ATOM:\", data.toString());\n  });\n\n  ProcessManager.add(child.pid);\n};\n","serve = function(path, handler) {\n  if (Package[\"iron:router\"]){\n    Package[\"iron:router\"].Router.route(path, function(){\n      handler(this.request, this.response, this.next);\n    }, {where: \"server\"});\n  } else {\n    WebApp.rawConnectHandlers.use(function(req, res, next){\n      if (req.path === path) {\n        handler(req, res, next);\n      } else {\n        next();\n      }\n    });\n  }\n};\n\nserveDir = function(dir, handler){\n  //path starts with dir\n  if (Package[\"iron:router\"]){\n    Package[\"iron:router\"].Router.route(dir + \"/:stuff\", function(){\n      handler(this.request, this.response, this.next);\n    }, {where: \"server\"});\n  } else {\n    var regex = new RegExp(\"^\" + dir);\n    WebApp.rawConnectHandlers.use(function(req, res, next){\n      if (regex.test(req.path)) {\n        handler(req, res, next);\n      } else {\n        next();\n      }\n    });\n  }\n};\n","serveDownloadUrl = function() {\n  serve('/app/download', function(req, res, next) {\n    var installerUrl = DOWNLOAD_URLS[req.query.platform];\n    if (_.isObject(installerUrl)) {\n      installerUrl = installerUrl.installer;\n    }\n    if (installerUrl) {\n      res.statusCode = 302; // Moved Temporarily\n      res.setHeader('Location', installerUrl);\n      res.end();\n    } else {\n      res.statusCode = 404;\n      res.end();\n    }\n  });\n};\n","var semver = Npm.require('semver');\nvar urlJoin = Npm.require('url-join');\nvar electronSettings = Meteor.settings.electron || {};\nvar latestVersion = electronSettings.version;\n\ncanServeUpdates = function(platform) {\n  if (!latestVersion){\n    return false;\n  }\n\n  return !!DOWNLOAD_URLS[platform];\n};\n\nUPDATE_FEED_PATH = \"/app/latest\";\n\nserveUpdateFeed = function() {\n  // https://github.com/Squirrel/Squirrel.Mac#server-support\n  if (canServeUpdates(\"darwin\")){\n    serve(UPDATE_FEED_PATH, function(req, res, next) {\n      var appVersion = req.query.version;\n      if (semver.valid(appVersion) && semver.gte(appVersion, latestVersion)) {\n        res.statusCode = 204; // No content.\n        res.end();\n      } else {\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'application/json');\n        res.end(JSON.stringify({\n          url: DOWNLOAD_URLS['darwin']\n        }));\n      }\n    });\n  }\n\n  // https://github.com/squirrel/squirrel.windows\n  // (Summary 'cause those docs are scant: the Windows app is going to expect the update feed URL\n  // to represent a directory from within which it can fetch the RELEASES file and packages. The\n  // above `serve` call serves _just_ '/app/latest', whereas this serves its contents.)\n  if (canServeUpdates(\"win32\")) {\n    // `path.dirname` works even on Windows.\n    var releasesUrl = DOWNLOAD_URLS['win32'].releases;\n    serveDir(UPDATE_FEED_PATH, function(req, res, next){\n      //first strip off the UPDATE_FEED_PATH\n      var path = req.url.split(UPDATE_FEED_PATH)[1];\n      res.statusCode = 302;\n      // Cache-bust the RELEASES file.\n      if (/RELEASES/.test(path)) {\n        path += (/\\?/.test(path) ? '&' : '?') + 'cb=' + Date.now();\n      }\n      res.setHeader(\"Location\", urlJoin(releasesUrl, path));\n      res.end();\n    });\n  }\n};\n","var electronSettings = Meteor.settings.electron || {};\n\nif ((process.env.NODE_ENV === 'development') && (electronSettings.autoBuild !== false)) {\n  var buildResults = createBinaries();\n  var buildResultForThisPlatform = buildResults[process.platform + '-' + process.arch];\n  if (buildResultForThisPlatform) {\n    launchApp(buildResultForThisPlatform.app, buildResultForThisPlatform.buildRequired);\n  }\n}\n\nserveDownloadUrl();\nserveUpdateFeed();\n"]}